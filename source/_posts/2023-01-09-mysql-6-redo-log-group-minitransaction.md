---
title: MySQL redo 日志分组和Mini-Transaction
categories: MySQL
tags: [MySQL, redo log]
date: 2023-01-09
---

## 以组的形式写redo日志

- 对于简单的redo日志，例如修改一个页上的数据，只有一行redolog，保证原子性可以认为比较简单
- 对于复杂的redo日志，例如插入一行记录，
	- 可能被插入的页面的空闲空间还足够，不需要分裂页面，也没有其他索引之类的插入，只要一条MLOG_COMP_REC_INSERT日志即可，这种插入称为`乐观插入`;
	- 可能涉及多个索引的B+树，每个B+树都可能涉及到叶子节点分裂，还可能涉及到中间节点的页分裂，还有系统数据页的修改等等，就可能产生多个redo日志记录，这种称为`悲观插入`。

这些redo日志很显然是不能分割的，称为`不可分割的组`。

- 更新Max Row ID属性时产生的redo日志为一组，不可分割；
- 向聚簇索引对应的B+树的页面插入一条记录时产生的redo日志是一组，是不可分割的；
- 向某个二级索引对应的B+树的页面插入一条记录时产生的redo日志是一组，是不可分割的；
- 还有一些其他的不可分割的组。

`向某个索引对应的B+树插入一条记录的过程必须是原子的，否则显然会产生一个不正确的B+树`,为了保证这种原子性，就要求redo日志的组不可分割的支持，即恢复时，对redo日志中某组的日志记录要么全都恢复要么都不恢复。

## 标记需要原子性得分组的实现原理

- 对于一组里有多条redo日志的情况

	在这组redo日志的最后再加一条`很简短`的日志记录，即`MLOG_MULTI_REC_END`这个日志记录只有1个type字节，值为31即0xFF，恢复时只有解析到MLOG_MULTI_REC_END的redo日志记录时，才会认为前面的redo日志是完整的组，否则丢弃前面的解析。

- 对于一组只有1条redo日志的情况

	一个type字段后8个bits，而redo日志的类型只有几十种，所以7个bits已经够用，留出第8个bit用来表示该条redo日志是否为单条一组，该bit为1即表示该redo为单条一组，为0表示多条一组，需要解析到MLOG_MULTI_REC_END日志记录

## Mini-Transaction

把对底层的原子性操作过程称为一个Mini-Transaction（MTR），例如修改一个Max Row ID 或者 向B+树中插入一条记录都是一个Mini-Transaction，一个MTR产生的redo日志就是一个不可分割的组。

一个事务可以包含多个语句，一个语句右可以包含多个MTR，每个MTR可以包含多个redo日志。

